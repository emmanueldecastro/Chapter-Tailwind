<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="/src/output.css">
  </head>
  <body>
    <header>
      <article>
        <h1>Software Engineering</h1>
      </article>
      <article>
        <h1>Chapter 7</h1>
      </article>
    </header>
    <nav class="nav1">
      <button><a href="">7.1 Object-oriented design using the UML</a></button>
      <button><a href="">7.2 Design patterns</a></button>
      <button><a href="">7.3 Implementation issues</a></button>
      <button><a href="">7.4 Open source development</a></button>
      
    </nav>
    <main>
      <section>
        <h1>DESIGN IMPLEMENTATION</h1>
      <section>
            <article>
          <p>
            Software design and implementation is the stage in the software
            engineering process at which an executable software system is
            developed. For some simple systems, software design and
            implementation is software engineering, and all other activities are
            merged with this process. However, for large systems, software
            design and implementation is only one of a set of processes
            (requirements engineering, verification and validation, etc.)
            involved in software engineering
          </p>
          <p>
            Software design and implementation activities are invariably
            interleaved. Software design is a creative activity in which you
            identify software components and their relationships, based on a
            customer’s requirements. Implementation is the process of realizing
            the design as a program. Sometimes, there is a separate design stage
            and this design is modeled and documented. At other times, a design
            is in the programmer’s head or roughly sketched on a whiteboard or
            sheets of paper. Design is about how to solve a problem, so there is
            always a design process. However, it isn’t always necessary or
            appropriate to describe the design in detail using the UML or other
            design description language.
          </p>
          <p>
            Design and implementation are closely linked and you should normally
            take implementation issues into account when developing a design.
            For example, using the UML to document a design may be the right
            thing to do if you are programming in an object-oriented language
            such as Java or C#. It is less useful, I think, if you are
            developing in a dynamically typed language like Python and makes no
            sense at all if you are implementing your system by configuring an
            off-the-shelf package. As I discussed in Chapter 3, agile methods
            usually work from informal sketches of the design and leave many
            design decisions to programmers.
          </p>
          <p>
            One of the most important implementation decisions that has to be
            made at an early stage of a software project is whether or not you
            should buy or build the application software. In a wide range of
            domains, it is now possible to buy off-the-shelf systems (COTS) that
            can be adapted and tailored to the users’ requirements. For example,
            if you want to implement a medical records system, you can buy a
            package that is already used in hospitals. It can be cheaper and
            faster to use this approach rather than developing a system in a
            conventional programming language.
          </p>
          <p>
            When you develop an application in this way, the design process
            becomes concerned with how to use the configuration features of that
            system to deliver the system requirements. You don’t usually develop
            design models of the system, such as models of the system objects
            and their interactions. I discuss this COTS-based approach to
            development in Chapter 16.
          </p>
          <p>
            I assume that most readers of this book will have had experience of
            program design and implementation. This is something that you
            acquire as you learn to program and master the elements of a
            programming language like Java or Python. You will have probably
            learned about good programming practice in the programming languages
            that you have studied, as well as how to debug programs that you
            have developed. Therefore, I don’t cover programming topics here.
            Instead, this chapter has two aims:
          </p>
          <ol>
            <li>
              To show how system modeling and architectural design (covered in
              Chapters 5 and 6) are put into practice in developing an
              object-oriented software design.
            </li>
            <li>
              To introduce important implementation issues that are not usually
              covered in programming books. These include software reuse,
              configuration management, and open source development.
            </li>
          </ol>
          <p>
            As there are a vast number of different development platforms, the
            chapter is not biased towards any particular programming language or
            implementation technology. Therefore, I have presented all examples
            using the UML rather than in a programming language such as Java or
            Python.
          </p>
          </article>
      </section>
      

          <article>
          <h3>7.1 Object-oriented design using the UML</h3>
          <p>
            An object-oriented system is made up of interacting objects that
            maintain their own local state and provide operations on that state.
            The representation of the state is private and cannot be accessed
            directly from outside the object. Object-oriented design processes
            involve designing object classes and the relationships between these
            classes. These classes define the objects in the system and their
            interactions. When the design is realized as an executing program,
            the objects are created dynamically from these class definitions.
            Object-oriented systems are easier to change than systems developed
            using functional approaches. Objects include both data and
            operations to manipulate that data. They may therefore be understood
            and modified as stand-alone entities. Changing the implementation of
            an object or adding services should not affect other system objects.
            Because objects are associated with things, there is often a clear
            mapping between realworld entities (such as hardware components) and
            their controlling objects in the system. This improves the
            understandability, and hence the maintainability, of the design. To
            develop a system design from concept to detailed, object-oriented
            design, there are several things that you need to do:
          </p>
          <ol>
            <li>
              Understand and define the context and the external interactions
              with the system.
            </li>
            <li>Design the system architecture.</li>
            <li>Identify the principal objects in the system.</li>
            <li>Develop design models</li>
            <li>Specify interfaces</li>
          </ol>
          <p>
            Like all creative activities, design is not a clear-cut, sequential
            process. You develop a design by getting ideas, proposing solutions,
            and refining these solutions as information becomes available. You
            inevitably have to backtrack and retry when problems arise.
            Sometimes you explore options in detail to see if they work; at
            other times you ignore details until late in the process.
            Consequently, I have deliberately not illustrated this process as a
            simple diagram because that would imply design can be thought of as
            a neat sequence of activities. In fact, all of the above activities
            are interleaved and so influence each other. I illustrate these
            process activities by designing part of the software for the
            wilderness weather station that I introduced in Chapter 1.
            Wilderness weather stations are deployed in remote areas. Each
            weather station records local weather information and periodically
            transfers this to a weather information system, using a satellite
            link.
          </p>
          </article>
          <h3>7.1.1 System context and interactions</h3>
          <p>
            The first stage in any software design process is to develop an
            understanding of the relationships between the software that is
            being designed and its external environment. This is essential for
            deciding how to provide the required system functionality and how to
            structure the system to communicate with its environment.
            Understanding of the context also lets you establish the boundaries
            of the system. Setting the system boundaries helps you decide what
            features are implemented in the system being designed and what
            features are in other associated systems. In this case, you need to
            decide how functionality is distributed between the control system
            for all of the weather stations, and the embedded software in the
            weather station itself.
          </p>
          <p>
            System context models and interaction models present complementary
            views of the relationships between a system and its environment:
          </p>
          <ol>
            <li>
              A system context model is a structural model that demonstrates the
              other systems in the environment of the system being developed.
            </li>
            <li>
              An interaction model is a dynamic model that shows how the system
              interacts with its environment as it is used.
            </li>
            <li>
              An interaction model is a dynamic model that shows how the system
              interacts with its environment as it is used.
            </li>
          </ol>
          <p>
            The context model of a system may be represented using associations.
            Associations simply show that there are some relationships between
            the entities involved in the association. The nature of the
            relationships is now specified. You may therefore document the
            environment of the system using a simple block diagram, showing the
            entities in the system and their associations. This is illustrated
            in Figure 7.1, which shows that
          </p>
          <p>
            the systems in the environment of each weather station are a weather
            information system, an onboard satellite system, and a control
            system. The cardinality information on the link shows that there is
            one control system but several weather stations, one satellite, and
            one general weather information system.
          </p>
          <p>
            When you model the interactions of a system with its environment you
            should use an abstract approach that does not include too much
            detail. One way to do this is to use a use case model. As I
            discussed in Chapters 4 and 5, each use case represents an
            interaction with the system. Each possible interaction is named in
            an ellipse and the external entity involved in the interaction is
            represented by a stick figure
          </p>
          <p>
            The use case model for the weather station is shown in Figure 7.2.
            This shows that the weather station interacts with the weather
            information system to report weather data and the status of the
            weather station hardware. Other interactions are with a control
            system that can issue specific weather station control commands. As
            I explained in Chapter 5, a stick figure is used in the UML to
            represent other systems as well as human users.
          </p>
          <p>
            Each of these use cases should be described in structured natural
            language. This helps designers identify objects in the system and
            gives them an understanding of what the system is intended to do. I
            use a standard format for this description that clearly identifies
            what information is exchanged, how the interaction is initiated, and
          </p>
          <figure>
          <img
            src="https://cs.ccsu.edu/~stan/classes/CS410/Notes16/images/07-context_model.png"
            alt=""
            height="200px"
          />
          <article>
            <img
              src="https://image1.slideserve.com/2401032/figure-7-2-weather-station-use-cases-l.jpg"
              alt=""
              height="300px"
            />
          </article>
          </figure>
          <p>
            so on. This is shown in Figure 7.3, which describes the Report
            weather use case from Figure 7.2. Examples of some other use cases
            are on the Web.
          </p>
          <h3>7.1.2 Architectural design</h3>
          <p>
            Once the interactions between the software system and the system’s
            environment have been defined, you use this information as a basis
            for designing the system architecture. Of course, you need to
            combine this with your general knowledge of the principles of
            architectural design and with more detailed domain knowledge.
          </p>

          <figure>
            <img src="Pictures/pic.png.png" alt="" />
          </figure>

          <figure>          <img
            src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSi7a_T1yaeFl9UZf2mU5Kshq4PLM9m8MJBIw&ss"
            alt=""
          /></figure>

          <p>
            You identify the major components that make up the system and their
            interactions, and then may organize the components using an
            architectural pattern such as a layered or client–server model.
            However, this is not essential at this stage.
          </p>
          <p>
            The high-level architectural design for the weather station software
            is shown in Figure 7.4. The weather station is composed of
            independent subsystems that communicate by broadcasting messages on
            a common infrastructure, shown as the Communication link in Figure
            7.4. Each subsystem listens for messages on that infrastructure and
            picks up the messages that are intended for them. This is another
            commonly used architectural style in addition to those described in
            Chapter 6.
          </p>
          <p>
            For example, when the communications subsystem receives a control
            command, such as shutdown, the command is picked up by each of the
            other subsystems, which then shut themselves down in the correct
            way. The key benefit of this architecture is that it is easy to
            support different configurations of subsystems because the sender of
            a message does not need to address the message to a particular
            subsystem.
          </p>
          <p>
            Figure 7.5 shows the architecture of the data collection subsystem,
            which is included in Figure 7.4. The Transmitter and Receiver
            objects are concerned with managing communications and the
            WeatherData object encapsulates the information that is collected
            from the instruments and transmitted to the weather information
            system. This arrangement follows the producer-consumer pattern,
            discussed in Chapter 20.
          </p>

          <h3>7.1.3 Object class identification</h3>
          <p>
            By this stage in the design process, you should have some ideas
            about the essential objects in the system that you are designing. As
            your understanding of the design develops, you refine these ideas
            about the system objects. The use case description helps to identify
            objects and operations in the system. From the description of the
            Report weather use case, it is obvious that objects representing the
            instruments that collect weather data will be required, as will an
            object representing the summary of the weather data. You also
            usually need a high-level
          </p>
            <figure>  <img
            src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTUDer3GU5vZlNTa9XYlLco3cBEUkQf8fBVHQ&s"
            alt=""
          /></figure>
          <p>
            system object or objects that encapsulate the system interactions
            defined in the use cases. With these objects in mind, you can start
            to identify the object classes in the system.
          </p>
          <p>
            There have been various proposals made about how to identify object
            classes in object-oriented systems:
          </p>
          <ol>
            <li>
              Use a grammatical analysis of a natural language description of
              the system to be constructed. Objects and attributes are nouns;
              operations or services are verbs (Abbott, 1983).
            </li>
            <li>
              Use tangible entities (things) in the application domain such as
              aircraft, roles such as manager or doctor, events such as
              requests, interactions such as meetings, locations such as
              offices, organizational units such as companies, and so on (Coad
              and Yourdon, 1990; Shlaer and Mellor, 1988; Wirfs-Brock et al.,
              1990).
            </li>
            <li>
              Use a scenario-based analysis where various scenarios of system
              use are identified and analyzed in turn. As each scenario is
              analyzed, the team responsible for the analysis must identify the
              required objects, attributes, and operations (Beck and Cunningham,
              1989).
            </li>
          </ol>
          <p>
            In practice, you have to use several knowledge sources to discover
            object classes. Object classes, attributes, and operations that are
            initially identified from the informal system description can be a
            starting point for the design. Further information from application
            domain knowledge or scenario analysis may then be used to refine and
            extend the initial objects. This information can be collected from
            requirements documents, discussions with users, or from analyses of
            existing systems.
          </p>

          <p>
            In the wilderness weather station, object identification is based on
            the tangible hardware in the system. I don’t have space to include
            all the system objects here, but I have shown five object classes in
            Figure 7.6. The Ground thermometer, Anemometer, and Barometer
            objects are application domain objects, and the WeatherStation and
            WeatherData objects have been identified from the system description
            and the scenario (use case) description:
          </p>

          <ol>
            <li>
              The WeatherStation object class provides the basic interface of
              the weather station with its environment. Its operations reflect
              the interactions shown in
            </li>
            <figure>
            <img
              src="https://d2vlcm61l7u1fs.cloudfront.net/media%2F771%2F77158d1e-f968-4378-b5b2-d9c3e0bdaff5%2FphpVV9v4I.png"
              height="400px"
              width="600x"
            />
            </figure>
           

            <p></p>

            <li>
              The WeatherData object class is responsible for processing the
              report weather command. It sends the summarized data from the
              weather station instruments to the weather information system.
            </li>
            <li>
              The Ground thermometer, Anemometer, and Barometer object classes
              are directly related to instruments in the system. They reflect
              tangible hardware entities in the system and the operations are
              concerned with controlling that hardware. These objects operate
              autonomously to collect data at the specified frequency and store
              the collected data locally. This data is delivered to the
              WeatherData object on request
            </li>
          </ol>
          <p>
            You use knowledge of the application domain to identify other
            objects, attributes, and services. We know that weather stations are
            often located in remote places and include various instruments that
            sometimes go wrong. Instrument failures should be reported
            automatically. This implies that you need attributes and operations
            to check the correct functioning of the instruments. There are many
            remote weather stations so each weather station should have its own
            identifier.
          </p>
          <p>
            At this stage in the design process, you should focus on the objects
            themselves, without thinking about how these might be implemented.
            Once you have identified the objects, you then refine the object
            design. You look for common features and then design the inheritance
            hierarchy for the system. For example, you may identify an
            Instrument superclass, which defines the common features of all
            instruments, such as an identifier, and get and test operations. You
            may also add new attributes and operations to the superclass, such
            as an attribute that maintains the frequency of data collection.
          </p>

          <h3>7.1.4 Design models</h3>
          <p>
            Design or system models, as I discussed in Chapter 5, show the
            objects or object classes in a system. They also show the
            associations and relationships between these entities. These models
            are the bridge between the system requirements and the
            implementation of a system. They have to be abstract so that
            unnecessary detail doesn’t hide the relationships between them and
            the system requirements.
          </p>
          <p>
            However, they also have to include enough detail for programmers to
            make implementation decisions.
          </p>
          <p>
            Generally, you get around this type of conflict by developing models
            at different levels of detail. Where there are close links between
            requirements engineers, designers, and programmers, then abstract
            models may be all that are required. Specific design decisions may
            be made as the system is implemented, with problems resolved through
            informal discussions. When the links between system specifiers,
            designers, and programmers are indirect (e.g., where a system is
            being designed in one part of an organization but implemented
            elsewhere), then more detailed models are likely to be needed.
          </p>
          <p>
            An important step in the design process, therefore, is to decide on
            the design models that you need and the level of detail required in
            these models. This depends on the type of system that is being
            developed. You design a sequential data-processing system in a
            different way from an embedded real-time system, so you will need
            different design models. The UML supports 13 different types of
            models but, as I discussed in Chapter 5, you rarely use all of
            these. Minimizing the number of models that are produced reduces the
            costs of the design and the time required to complete the design
            process.
          </p>
          <p>
            When you use the UML to develop a design, you will normally develop
            two kinds of design model:
          </p>

          <ol>
            <li>
              Structural models, which describe the static structure of the
              system using object classes and their relationships. Important
              relationships that may be documented at this stage are
              generalization (inheritance) relationships, uses/used-by
              relationships, and composition relationships.
            </li>
            <li>
              Dynamic models, which describe the dynamic structure of the system
              and show the interactions between the system objects. Interactions
              that may be documented include the sequence of service requests
              made by objects and the state changes that are triggered by these
              object interactions.
            </li>
          </ol>

          <p>
            In the early stages of the design process, I think there are three
            models that are particularly useful for adding detail to use case
            and architectural models:
          </p>

          <ol>
            <li>
              Subsystem models, which that show logical groupings of objects
              into coherent subsystems. These are represented using a form of
              class diagram with each subsystem shown as a package with enclosed
              objects. Subsystem models are static (structural) models.
            </li>
              <figure> <img
              src="https://image1.slideserve.com/2401032/figure-7-7-sequence-diagram-describing-data-collection-l.jpg"
            height="400px"
            width="600px"
            /></figure>
           
            <li>
              . Sequence models, which show the sequence of object interactions.
              These are represented using a UML sequence or a collaboration
              diagram. Sequence models are dynamic models.
            </li>
            <li>
              State machine model, which show how individual objects change
              their state in response to events. These are represented in the
              UML using state diagrams. State machine models are dynamic models.
            </li>
          </ol>
          <p>
            A subsystem model is a useful static model as it shows how a design
            is organized into logically related groups of objects. I have
            already shown this type of model in Figure 7.4 to show the
            subsystems in the weather mapping system. As well as subsystem
            models, you may also design detailed object models, showing all of
            the objects in the systems and their associations (inheritance,
            generalization, aggregation, etc.). However, there is a danger in
            doing too much modeling. You should not make detailed decisions
            about the implementation that really should be left to the system
            programmers.
          </p>
          <p>
            Sequence models are dynamic models that describe, for each mode of
            interaction, the sequence of object interactions that take place.
            When documenting a design, you should produce a sequence model for
            each significant interaction. If you have developed a use case model
            then there should be a sequence model for each use case that you
            have identified.
          </p>
          <p>
            Figure 7.7 is an example of a sequence model, shown as a UML
            sequence diagram. This diagram shows the sequence of interactions
            that take place when an external system requests the summarized data
            from the weather station. You read sequence diagrams from top to
            bottom:
          </p>
          <ol>
            <li>
              The SatComms object receives a request from the weather
              information system to collect a weather report from a weather
              station. It acknowledges receipt of this request. The stick
              arrowhead on the sent message indicates that the external system
              does not wait for a reply but can carry on with other processing.
            </li>
            <li>
              SatComms sends a message to WeatherStation, via a satellite link,
              to create a summary of the collected weather data. Again, the
              stick arrowhead indicates that SatComms does not suspend itself
              waiting for a reply
            </li>
            <li>
              WeatherStation sends a message to a Commslink object to summarize
              the weather data. In this case, the squared-off style of arrowhead
              indicates that the instance of the WeatherStation object class
              waits for a reply
            </li>
            <li>
              Commslink calls the summarize method in the object WeatherData and
              waits for a reply.
            </li>
            <li>
              The weather data summary is computed and returned to
              WeatherStation via the Commslink object.
            </li>
            <li>
              WeatherStation then calls the SatComms object to transmit the
              summarized data to the weather information system, through the
              satellite communications system.
            </li>
          </ol>
          <p>
            WeatherStation then calls the SatComms object to transmit the
            summarized data to the weather information system, through the
            satellite communications system.
          </p>
          <p>
            Sequence diagrams are used to model the combined behavior of a group
            of objects but you may also want to summarize the behavior of an
            object or a subsystem in response to messages and events. To do
            this, you can use a state machine model that shows how the object
            instance changes state depending on the messages that it receives.
            The UML includes state diagrams, initially invented by Harel (1987)
            to describe state machine models.
          </p>
          <p>
            Figure 7.8 is a state diagram for the weather station system that
            shows how it responds to requests for various services.
          </p>
          <p>You can read this diagram as follows:</p>
          <ol>
            <li>
              If the system state is Shutdown then it can respond to a
              restart(), a reconfigure(), or a powerSave() message. The
              unlabeled arrow with the black blob indicates that the Shutdown
              state is the initial state. A restart() message causes a
              transition to normal operation. Both the powerSave() and
              reconfigure() messages cause a transition to a state in which the
              system reconfigures itself. The state diagram shows that
              reconfiguration is only allowed if the system has been shut down.
            </li>
            <li>
              In the Running state, the system expects further messages. If a
              shutdown() message is received, the object returns to the shutdown
              state.
            </li>
            <li>
              If a reportWeather() message is received, the system moves to the
              Summarizing state. When the summary is complete, the system moves
              to a Transmitting state where the information is transmitted to
              the remote system. It then returns to the Running state.
            </li>
            <figure>
            <img
              src="https://image1.slideserve.com/2401032/figure-7-8-weather-station-state-diagram-l.jpg"
              height="400px"
              width="500px"
            />
            </figure>
            <li>
              If a reportStatus() message is received, the system moves to the
              Testing state, then the Transmitting state, before returning to
              the Running state.
            </li>
            <li>
              If a signal from the clock is received, the system moves to the
              Collecting state, where it collects data from the instruments.
              Each instrument is instructed in turn to collect its data from the
              associated sensors.
            </li>
            <li>
              If a remoteControl() message is received, the system moves to a
              controlled state in which it responds to a different set of
              messages from the remote control room. These are not shown on this
              diagram.
            </li>
          </ol>
          <p>
            State diagrams are useful high-level models of a system or an
            object’s operation. You don’t usually need a state diagram for all
            of the objects in the system. Many of the objects in a system are
            relatively simple and a state model adds unnecessary detail to the
            design.
          </p>
          <h3>7.1.5 Interface specification</h3>
          <p>
            An important part of any design process is the specification of the
            interfaces between the components in the design. You need to specify
            interfaces so that objects and subsystems can be designed in
            parallel. Once an interface has been specified, the developers of
            other objects may assume that interface will be implemented.
          </p>
          <p>
            Interface design is concerned with specifying the detail of the
            interface to an object or to a group of objects. This means defining
            the signatures and semantics of
          </p>
          </figure>
          <img
            src="https://image1.slideserve.com/2401032/figure-7-9-weather-station-interfaces-l.jpg"
            height="400px"
            height="600"
          />
          </figure>
          <p>
            the services that are provided by the object or by a group of
            objects. Interfaces can be specified in the UML using the same
            notation as a class diagram. However, there is no attribute section
            and the UML stereotype ‹‹interface›› should be included in the name
            part. The semantics of the interface may be defined using the object
            constraint language (OCL). I explain this in Chapter 17, where I
            cover component-based software engineering. I also show an
            alternative way to represent interfaces in the UML. You should not
            include details of the data representation in an interface design,
            as attributes are not defined in an interface specification.
            However, you should include operations to access and update data. As
            the data representation is hidden, it can be easily changed without
            affecting the objects that use that data. This leads to a design
            that is inherently more maintainable. For example, an array
            representation of a stack may be changed to a list representation
            without affecting other objects that use the stack. By contrast, it
            often makes sense to expose the attributes in a static design model,
            as this is the most compact way of illustrating essential
            characteristics of the objects.
          </p>
          <p>
            There is not a simple 1:1 relationship between objects and
            interfaces. The same object may have several interfaces, each of
            which is a viewpoint on the methods that it provides. This is
            supported directly in Java, where interfaces are declared separately
            from objects and objects ‘implement’ interfaces. Equally, a group of
            objects may all be accessed through a single interface
          </p>
          <p>
            Figure 7.9 shows two interfaces that may be defined for the weather
            station. The left-hand interface is a reporting interface that
            defines the operation names that are used to generate weather and
            status reports. These map directly to operations in the
            WeatherStation object. The remote control interface provides four
            operations, which map onto a single method in the WeatherStation
            object. In this case, the individual operations are encoded in the
            command string associated with the remoteControl method, shown in
            Figure 7.6.
          </p>
          <h3>7.2 Design patterns</h3>
          <p>
            Design patterns were derived from ideas put forward by Christopher
            Alexander (Alexander et al., 1977), who suggested that there were
            certain common patterns of building design that were inherently
            pleasing and effective. The pattern is a description of the problem
            and the essence of its solution, so that the solution may be reused
            in
          </p>

          <figure>
            <img src="Pictures/comment.png" alt="" />
          </figure>

          <p>
            different settings. The pattern is not a detailed specification.
            Rather, you can think of it as a description of accumulated wisdom
            and experience, a well-tried solution to a common problem.
          </p>
          <p>
            A quote from the Hillside Group web site (http://hillside.net),
            which is dedicated to maintaining information about patterns,
            encapsulates their role in reuse:
          </p>
          <p>
            Patterns and Pattern Languages are ways to describe best practices,
            good designs, and capture experience in a way that it is possible
            for others to reuse this experience.
          </p>
          <p>
            Patterns have made a huge impact on object-oriented software design.
            As well as being tested solutions to common problems, they have
            become a vocabulary for talking about a design. You can therefore
            explain your design by describing the patterns that you have used.
            This is particularly true for the best-known design patterns that
            were originally described by the ‘Gang of Four’ in their patterns
            book, (Gamma et al., 1995). Other particularly important pattern
            descriptions are those published in a series of books by authors
            from Siemens, a large European technology company (Buschmann et al.,
            1996; Buschmann et al., 2007a; Buschmann et al., 2007b; Kircher and
            Jain, 2004; Schmidt et al., 2000).
          </p>
          <p>
            Design patterns are usually associated with object-oriented design.
            Published patterns often rely on object characteristics such as
            inheritance and polymorphism to provide generality. However, the
            general principle of encapsulating experience in a
          </p>
          <img src="Pictures/piktur.png" alt="" />
          <p>
            pattern is one that is equally applicable to any kind of software
            design. So, you could have configuration patterns for COTS systems.
            Patterns are a way of reusing the knowledge and experience of other
            designers.
          </p>
          <p>
            The four essential elements of design patterns were defined by the
            ‘Gang of Four’ in their patterns book:
          </p>

          <ol>
            <li>A name that is a meaningful reference to the pattern.</li>
            <li>
              A description of the problem area that explains when the pattern
              may be applied.
            </li>
            <li>
              A solution description of the parts of the design solution, their
              relationships, and their responsibilities. This is not a concrete
              design description. It is a template for a design solution that
              can be instantiated in different ways. This is often expressed
              graphically and shows the relationships between the objects and
              object classes in the solution.
            </li>
            <li>
              A statement of the consequences—the results and trade-offs—of
              applying the pattern. This can help designers understand whether
              or not a pattern can be used in a particular situation.
            </li>
          </ol>
          <p>
            Gamma and his co-authors break down the problem description into
            motivation (a description of why the pattern is useful) and
            applicability (a description of situations in which the pattern may
            be used). Under the description of the solution, they describe the
            pattern structure, participants, collaborations, and implementation.
          </p>
          <p>
            To illustrate pattern description, I use the Observer pattern, taken
            from the book by Gamma et al. (Gamma et al., 1995). This is shown in
            Figure 7.10. In my description, I use the four essential description
            elements and also include a brief statement of what the pattern can
            do. This pattern can be used in situations where different
            presentations of an object’s state are required. It separates the
            object that must be displayed from the different forms of
            presentation. This is illustrated in Figure 7.11, which shows two
            graphical presentations of the same data set.
          </p>
          <p>
            Graphical representations are normally used to illustrate the object
            classes in patterns and their relationships. These supplement the
            pattern description and add
          </p>
          <img src="Pictures/piktur2.png" alt="" />
          <p>
            detail to the solution description. Figure 7.12 is the
            representation in UML of the Observer pattern.
          </p>
          <p>
            To use patterns in your design, you need to recognize that any
            design problem you are facing may have an associated pattern that
            can be applied. Examples of such problems, documented in the ‘Gang
            of Four’s original patterns book, include:
          </p>
          <ol>
            <li>
              Tell several objects that the state of some other object has
              changed (Observer pattern).
            </li>
            <li>
              Tidy up the interfaces to a number of related objects that have
              often been developed incrementally (Façade pattern).
            </li>
            <li>
              Provide a standard way of accessing the elements in a collection,
              irrespective of how that collection is implemented (Iterator
              pattern).
            </li>
            <li>
              Allow for the possibility of extending the functionality of an
              existing class at run-time (Decorator pattern).
            </li>
          </ol>
          <p>
            Patterns support high-level, concept reuse. When you try to reuse
            executable components you are inevitably constrained by detailed
            design decisions that have been made by the implementers of these
            components. These range from the particular algorithms that have
            been used to implement the components to the objects and types in
            the component interfaces. When these design decisions conflict with
            your particular requirements, reusing the component is either
            impossible or introduces inefficiencies into your system. Using
            patterns means that you reuse the ideas but can adapt the
            implementation to suit the system that you are developing.
          </p>
          <p>
            When you start designing a system, it can be difficult to know, in
            advance, if you will need a particular pattern. Therefore, using
            patterns in a design process often involves developing a design,
            experiencing a problem, and then recognizing that a pattern can be
            used. This is certainly possible if you focus on the 23
            general-purpose patterns documented in the original patterns book.
            However, if your problem is a different one, you may find it
            difficult to find an appropriate pattern amongst the hundreds of
            different patterns that have been proposed. Patterns are a great
            idea but you need experience
          </p>
          <p>
            effectively. You have to recognize situations where a pattern can be
            applied. Inexperienced programmers, even if they have read the
            pattern books, will always find it hard to decide whether they can
            reuse a pattern or need to develop a specialpurpose solution.
          </p>
          <h3>7.3 implementation issues</h3>
          <p>
            Software engineering includes all of the activities involved in
            software development from the initial requirements of the system
            through to maintenance and management of the deployed system. A
            critical stage of this process is, of course, system implementation,
            where you create an executable version of the software.
            Implementation may involve developing programs in high- or low-level
            programming languages or tailoring and adapting generic,
            off-the-shelf systems to meet the specific requirements of an
            organization.
          </p>
          <p>
            I assume that most readers of this book will understand programming
            principles and will have some programming experience. As this
            chapter is intended to offer a language-independent approach, I
            haven’t focused on issues of good programming practice as this has
            to use language-specific examples. Instead, I introduce some aspects
            of implementation that are particularly important to software
            engineering that are often not covered in programming texts. These
            are:
          </p>
          <ol>
            <li>
              Reuse Most modern software is constructed by reusing existing
              components or systems. When you are developing software, you
              should make as much use as possible of existing code.
            </li>
            <li>
              Configuration management During the development process, many
              different versions of each software component are created. If you
              don’t keep track of these versions in a configuration management
              system, you are liable to include the wrong versions of these
              components in your system.
            </li>
            <li>
              Host-target development Production software does not usually
              execute on the same computer as the software development
              environment. Rather, you develop it on one computer (the host
              system) and execute it on a separate computer (the target system).
              The host and target systems are sometimes of the same type but,
              often they are completely different.
            </li>
          </ol>
          <h3>7.3.1 Reuse</h3>
          <p>
            From the 1960s to the 1990s, most new software was developed from
            scratch, by writing all code in a high-level programming language.
            The only significant reuse or software was the reuse of functions
            and objects in programming language libraries. However, costs and
            schedule pressure meant that this approach became increasingly
            unviable, especially for commercial and Internet-based systems.
            Consequently, an approach to development based around the reuse of
            existing software emerged and is now generally used for business
            systems, scientific software, and, increasingly, in embedded systems
            engineering.
          </p>
          <p>Software reuse is possible at a number of different levels:</p>
          <ol>
            <li>
              The abstraction level At this level, you don’t reuse software
              directly but rather use knowledge of successful abstractions in
              the design of your software. Design patterns and architectural
              patterns (covered in Chapter 6) are ways of representing abstract
              knowledge for reuse.
            </li>
            <li>
              The object level At this level, you directly reuse objects from a
              library rather than writing the code yourself. To implement this
              type of reuse, you have to find appropriate libraries and discover
              if the objects and methods offer the functionality that you need.
              For example, if you need to process mail messages in a Java
              program, you may use objects and methods from a JavaMail library.
            </li>
            <li>
              The component level Components are collections of objects and
              object classes that operate together to provide related functions
              and services. You often have to adapt and extend the component by
              adding some code of your own. An example of component-level reuse
              is where you build your user interface using a framework. This is
              a set of general object classes that implement event handling,
              display management, etc. You add connections to the data to be
              displayed and write code to define specific display details such
              as screen layout and colors.
            </li>
            <li>
              The system level At this level, you reuse entire application
              systems. This usually involves some kind of configuration of these
              systems. This may be done by adding and modifying code (if you are
              reusing a software product line) or by using the system’s own
              configuration interface. Most commercial systems are now built in
              this way where generic COTS (commercial off-the-shelf) systems are
              adapted and reused. Sometimes this approach may involve reusing
              several different systems and integrating these to create a new
              system.
            </li>
          </ol>
          <p>
            By reusing existing software, you can develop new systems more
            quickly, with fewer development risks and also lower costs. As the
            reused software has been tested in other applications, it should be
            more reliable than new software. However, there are costs associated
            with reuse:
          </p>
          <ol>
            <li>
              The costs of the time spent in looking for software to reuse and
              assessing whether or not it meets your needs. You may have to test
              the software to make sure that it will work in your environment,
              especially if this is different from its development environment.
            </li>
            <li>
              Where applicable, the costs of buying the reusable software. For
              large off-theshelf systems, these costs can be very high.
            </li>
            <li>
              The costs of adapting and configuring the reusable software
              components or systems to reflect the requirements of the system
              that you are developing.
            </li>

            <li>
              The costs of integrating reusable software elements with each
              other (if you are using software from different sources) and with
              the new code that you have developed. Integrating reusable
              software from different providers can be difficult and expensive
              because the providers may make conflicting assumptions about how
              their respective software will be reused.
            </li>
          </ol>
          <p>
            How to reuse existing knowledge and software should be the first
            thing you should think about when starting a software development
            project. You should consider the possibilities of reuse before
            designing the software in detail, as you may wish to adapt your
            design to reuse existing software assets. As I discussed in Chapter
            2, in a reuseoriented development process, you search for reusable
            elements then modify your requirements and design to make best use
            of these.
          </p>
          <p>
            For a large number of application systems, software engineering
            really means software reuse. I therefore devote several chapters in
            the software technologies section of the book to this topic
            (Chapters 16, 17, and 19).
          </p>
          <h3>7.3.2 Configuration management</h3>
          <p>
            In software development, change happens all the time, so change
            management is absolutely essential. When a team of people are
            developing software, you have to make sure that team members don’t
            interfere with each others’ work. That is, if two people are working
            on a component, their changes have to be coordinated. Otherwise, one
            programmer may make changes and overwrite the other’s work. You also
            have to ensure that everyone can access the most up-to-date versions
            of software components, otherwise developers may redo work that has
            already been done. When something goes wrong with a new version of a
            system, you have to be able to go back to a working version of the
            system or component.
          </p>
          <p>
            Configuration management is the name given to the general process of
            managing a changing software system. The aim of configuration
            management is to support the system integration process so that all
            developers can access the project code and documents in a controlled
            way, find out what changes have been made, and compile and link
            components to create a system. There are, therefore, three
            fundamental configuration management activities:
          </p>
          <ol>
            <li>
              Version management, where support is provided to keep track of the
              different versions of software components. Version management
              systems include facilities to coordinate development by several
              programmers. They stop one developer overwriting code that has
              been submitted to the system by someone else.
            </li>
            <li>
              System integration, where support is provided to help developers
              define what versions of components are used to create each version
              of a system. This description is then used to build a system
              automatically by compiling and linking the required components.
            </li>
            <li>
              Problem tracking, where support is provided to allow users to
              report bugs and other problems, and to allow all developers to see
              who is working on these problems and when they are fixed.
            </li>
          </ol>
          <p>
            Software configuration management tools support each of the above
            activities. These tools may be designed to work together in a
            comprehensive change management system, such as ClearCase (Bellagio
            and Milligan, 2005). In integrated configuration management systems,
            version management, system integration, and problem-tracking tools
            are designed together. They share a user interface style and are
            integrated through a common code repository.
          </p>
          <p>
            Alternatively, separate tools, installed in an integrated
            development environment, may be used. Version management may be
            supported using a version management system such as Subversion
            (Pilato et al., 2008), which can support multi-site, multiteam
            development. System integration support may be built into the
            language or rely on a separate toolset such as the GNU build system.
            This includes what is perhaps the best-known integration tool, Unix
            make. Bug tracking or issue tracking systems, such as Bugzilla, are
            used to report bugs and other issues and to keep track of whether or
            not these have been fixed.
          </p>
          <p>
            Because of its importance in professional software engineering, I
            discuss change and configuration management in more detail in
            Chapter 25.
          </p>
          <h3>7.3.3 Host-target development</h3>
          <p>
            Most software development is based on a host-target model. Software
            is developed on one computer (the host), but runs on a separate
            machine (the target). More generally, we can talk about a
            development platform and an execution platform. A platform is more
            than just hardware. It includes the installed operating system plus
            other supporting software such as a database management system or,
            for development platforms, an interactive development environment.
          </p>
          <p>
            Sometimes, the development and execution platforms are the same,
            making it possible to develop the software and test it on the same
            machine. More commonly, however, they are different so that you need
            to either move your developed software to the execution platform for
            testing or run a simulator on your development machine.
          </p>
          <p>
            Simulators are often used when developing embedded systems. You
            simulate hardware devices, such as sensors, and the events in the
            environment in which the system will be deployed. Simulators speed
            up the development process for embedded systems as each developer
            can have their own execution platform with no need to download the
            software to the target hardware. However, simulators are expensive
            to develop and so are only usually available for the most popular
            hardware architectures.
          </p>
          <p>
            If the target system has installed middleware or other software that
            you need to use, then you need to be able to test the system using
            that software. It may be impractical to install that software on
            your development machine, even if it is the same as the target
            platform, because of license restrictions. In those circumstances,
            you need to transfer your developed code to the execution platform
            to test the system.
          </p>
          <p>
            A software development platform should provide a range of tools to
            support software engineering processes. These may include:
          </p>
          <ol>
            <li>
              An integrated compiler and syntax-directed editing system that
              allows you to create, edit, and compile code.
            </li>
            <li>A language debugging system</li>
            <li>Graphical editing tools, such as tools to edit UML models.</li>
            <li>
              Testing tools, such as JUnit (Massol, 2003) that can automatically
              run a set of tests on a new version of a program.
            </li>
            <li>
              Project support tools that help you organize the code for
              different development projects.
            </li>
          </ol>
          <p>
            As well as these standard tools, your development system may include
            more specialized tools such as static analyzers (discussed in
            Chapter 15). Normally, development environments for teams also
            include a shared server that runs a change and configuration
            management system and, perhaps, a system to support requirements
            management.
          </p>
          <p>
            Software development tools are often grouped to create an integrated
            development environment (IDE). An IDE is a set of software tools
            that supports different aspects of software development, within some
            common framework and user interface. Generally, IDEs are created to
            support development in a specific programming language such as Java.
            The language IDE may be developed specially, or may be an
            instantiation of a general-purpose IDE, with specific
            language-support tools.
          </p>
          <p>
            A general-purpose IDE is a framework for hosting software tools that
            provides data management facilities for the software being
            developed, and integration mechanisms, that allow tools to work
            together. The best-known general-purpose IDE is the Eclipse
            environment (Carlson, 2005). This environment is based on a plug-in
            architecture so that it can be specialized for different languages
            and application domains (Clayberg and Rubel, 2006). Therefore, you
            can install Eclipse and tailor it for your specific needs by adding
            plug-ins. For example, you may add a set of plug-ins to support
            networked systems development in Java or embedded systems
            engineering using C.
          </p>
          <p>
            As part of the development process, you need to make decisions about
            how the developed software will be deployed on the target platform.
            This is straightforward for embedded systems, where the target is
            usually a single computer. However, for distributed systems, you
            need to decide on the specific platforms where the components will
            be deployed. Issues that you have to consider in making this
            decision are:
          </p>
          <ol>
            <li>
              The hardware and software requirements of a component If a
              component is designed for a specific hardware architecture, or
              relies on some other software system, it must obviously be
              deployed on a platform that provides the required hardware and
              software support.
            </li>
            <li>
              The availability requirements of the system High-availability
              systems may require components to be deployed on more than one
              platform. This means that, in the event of platform failure, an
              alternative implementation of the component is available.
            </li>
            <li>
              Component communications If there is a high level of
              communications traffic between components, it usually makes sense
              to deploy them on the same platform or on platforms that are
              physically close to one other. This reduces communications
              latency, the delay between the time a message is sent by one
              component and received by another.
            </li>
          </ol>
          <p>
            You can document your decisions on hardware and software deployment
            using UML deployment diagrams, which show how software components
            are distributed across hardware platforms.
          </p>
          <p>
            If you are developing an embedded system, you may have to take into
            account target characteristics, such as its physical size, power
            capabilities, the need for realtime responses to sensor events, the
            physical characteristics of actuators, and its realtime operating
            system. I discuss embedded systems engineering in Chapter 20.
          </p>
          <h3>7.4 Open source development</h3>
          <p>
            Open source development is an approach to software development in
            which the source code of a software system is published and
            volunteers are invited to participate in the development process
            (Raymond, 2001). Its roots are in the Free Software Foundation
            (http://www.fsf.org), which advocates that source code should not be
            proprietary but rather should always be available for users to
            examine and modify as they wish. There was an assumption that the
            code would be controlled and developed by a small core group, rather
            than users of the code.
          </p>
          <p>
            Open source software extended this idea by using the Internet to
            recruit a much larger population of volunteer developers. Many of
            them are also users of the code. In principle at least, any
            contributor to an open source project may report and fix bugs and
            propose new features and functionality. However, in practice,
            successful open source systems still rely on a core group of
            developers who control changes to the software.
          </p>
          <p>
            The best-known open source product is, of course, the Linux
            operating system which is widely used as a server system and,
            increasingly, as a desktop environment. Other important open source
            products are Java, the Apache web server, and the mySQL database
            management system. Major players in the computer industry such as
            IBM and Sun support the open source movement and base their software
            on open source products. There are thousands of other, lesser known
            open source systems and components that may also be used.
          </p>
          <p>
            It is usually fairly cheap or free to acquire open source software.
            You can normally download open source software without charge.
            However, if you want documentation and support, then you may have to
            pay for this, but costs are usually fairly low. The other key
            benefit of using open source products is that mature open source
            systems are usually very reliable. The reason for this is that they
            have a large population of users who are willing to fix problems
            themselves rather than report these problems to the developer and
            wait for a new release of the system. Bugs are discovered and
            repaired more quickly than is usually possible with proprietary
            software.
          </p>
          <p>
            For a company involved in software development, there are two open
            source issues that have to be considered:
          </p>
          <ol>
            <li>
              Should the product that is being developed make use of open source
              components?
            </li>
            <li>
              Should an open source approach be used for the software’s
              development?
            </li>
          </ol>
          <p>
            The answers to these questions depend on the type of software that
            is being developed and the background and experience of the
            development team.
          </p>
          <p>
            If you are developing a software product for sale, then time to
            market and reduced costs are critical. If you are developing in a
            domain in which there are high-quality open source systems
            available, you can save time and money by using these systems.
          </p>
          <p>
            However, if you are developing software to a specific set of
            organizational requirements, then using open source components may
            not be an option. You may have to integrate your software with
            existing systems that are incompatible with available open source
            systems. Even then, however, it could be quicker and cheaper to
            modify the open source system rather than redevelop the
            functionality that you need.
          </p>
          <p>
            More and more product companies are using an open source approach to
            development. Their business model is not reliant on selling a
            software product but rather on selling support for that product.
            They believe that involving the open source community will allow
            software to be developed more cheaply, more quickly, and will create
            a community of users for the software. Again, however, this is
            really only applicable for general software products rather than
            specific organizational applications.
          </p>
          <p>
            Many companies believe that adopting an open source approach will
            reveal confidential business knowledge to their competitors and so
            are reluctant to adopt this development model. However, if you are
            working in a small company and you open source your software, this
            may reassure customers that they will be able to support the
            software if your company goes out of business.
          </p>
          <p>
            Publishing the source code of a system does not mean that people
            from the wider community will necessarily help with its development.
            Most successful open source products have been platform products
            rather than application systems. There are a limited number of
            developers who might be interested in specialized application
            systems. As such, making a software system open source does not
            guarantee community involvement.
          </p>
          <h3>7.4.1 Open source licensing</h3>
          <p>
            Although a fundamental principle of open-source development is that
            source code should be freely available, this does not mean that
            anyone can do as they wish with that code. Legally, the developer of
            the code (either a company or an individual) still owns the code.
            They can place restrictions on how it is used by including legally
            binding conditions in an open source software license (St. Laurent,
            2004). Some open source developers believe that if an open source
            component is used to develop a new system, then that system should
            also be open source. Others are willing to allow their code to be
            used without this restriction. The developed systems may be
            proprietary and sold as closed source systems.
          </p>
          <p>
            Most open source licenses are derived from one of three general
            models:
          </p>
          <ol>
            <li>
              The GNU General Public License (GPL). This is a so-called
              ‘reciprocal’ license that, simplistically, means that if you use
              open source software that is licensed under the GPL license, then
              you must make that software open source.
            </li>
            <li>
              The GNU Lesser General Public License (LGPL). This is a variant of
              the GPL license where you can write components that link to open
              source code without having to publish the source of these
              components. However, if you change the licensed component, then
              you must publish this as open source.
            </li>
            <li>
              The Berkley Standard Distribution (BSD) License. This is a
              non-reciprocal license, which means you are not obliged to
              republish any changes or modifications made to open source code.
              You can include the code in proprietary systems that are sold. If
              you use open source components, you must acknowledge the original
              creator of the code.
            </li>
          </ol>
          <p>
            Licensing issues are important because if you use open-source
            software as part of a software product, then you may be obliged by
            the terms of the license to make your own product open source. If
            you are trying to sell your software, you may wish to keep it
            secret. This means that you may wish to avoid using GPL-licensed
            open source software in its development.
          </p>
          <p>
            If you are building software that runs on an open source platform,
            such as Linux, then licenses are not a problem. However, as soon as
            you start including open source components in your software you need
            to set up processes and databases to keep track of what’s been used
            and their license conditions. Bayersdorfer (2007) suggests that
            companies managing projects that use open source should:
          </p>
          <ol>
            <li>
              Establish a system for maintaining information about open source
              components that are downloaded and used. You have to keep a copy
              of the license for each component that was valid at the time the
              component was used. Licenses may change so you need to know the
              conditions that you have agreed to.
            </li>
            <li>
              Be aware of the different types of licenses and understand how a
              component is licensed before it is used. You may decide to use a
              component in one system but not in another because you plan to use
              these systems in different ways.
            </li>
            <li>
              Be aware of evolution pathways for components. You need to know a
              bit about the open source project where components are developed
              to understand how they might change in future.
            </li>
            <li>
              Educate people about open source. It’s not enough to have
              procedures in place to ensure compliance with license conditions.
              You also need to educate developers about open source and open
              source licensing.
            </li>
            <li>
              Have auditing systems in place. Developers, under tight deadlines,
              might be tempted to break the terms of a license. If possible, you
              should have software in place to detect and stop this.
            </li>
            <li>
              Participate in the open source community. If you rely on open
              source products, you should participate in the community and help
              support their development.
            </li>
          </ol>
          <p>
            The business model of software is changing. It is becoming
            increasingly difficult to build a business by selling specialized
            software systems. Many companies prefer to make their software open
            source and then sell support and consultancy to software users. This
            trend is likely to accelerate, with increasing use of open source
            software and with more and more software available in this form.
          </p>
        </article>
      </section>
    </main>
    <footer>
      <article>
        <h1>software engineering</h1>
        <p>© 2025 Emman Decastro</p>
      </article>
      <nav class="nav2">
        <h5>Contents</h5>
        <a href="">7.1 Object-oriented design using the UML</a>
        <a href="">7.2 Design patterns</a>
        <a href="">7.3 Implementation issues</a>
        <a href="">7.4 Open source development</a>
      </nav>
    </footer>
  </body>
</html>
