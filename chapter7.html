<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="/src/output.css">
  </head>
  <body class="bg-[#C8AE7E]">
    <header
  class="c7header bg-[#C8AE7E] bg-opacity-90  fixed top-0 left-0 w-full z-50">

  <div class="flex items-center space-x-3">
    <a href="/" class="flex items-center space-x-3" aria-label="Home">
      <img src="/Pictures/software-development.png" alt="Logo" width="50px" height="50px"
           class="c2logo" />
      <h1 class="c2title sour-gummy">
        Software Engineering
      </h1>
    </a>
  </div>

  <nav class="relative mt-2 sm:mt-0" aria-label="Chapter Navigation">
    <details class="group">
      <summary
        class="c2chapter2 sour-gummy">
        Chapter 2
      </summary>

      <ul
        class="c7ul sour-gummy">
        <li><a href="#design" class="font-bold c7list">DESIGN IMPLEMENTATION</a></li>
        <li><a href="#object" class="font-bold c7list">7.1 Object-oriented design using the UML</a></li>
        <li><a href="#system" class="c7list">7.1.1 System context and interactions</a></li>
        <li><a href="#Architectural" class="c7list">7.1.2 Architectural design</a></li>
        <li><a href="#OBJECT CLASS" class="c7list">7.1.3 Object Class Identification</a></li>
        <li><a href="#design models" class="font-bold c7list">7.1.4 Design Models</a></li>
        <li><a href="#interface" class="c7list">7.1.5 Interface Specification</a></li>
        <li><a href="#design patterns" class="c7list">7.2 Design patterns</a></li>
        <li><a href="#implementation" class="c7list">7.3 Implementation Issues</a></li>
        <li><a href="#configuration" class="c7list">7.3.2 Configuration Management</a></li>
        <li><a href="#host-target" class="font-bold c7list">7.3.3 Host-target Development</a></li>
        <li><a href="#open source" class="c7list">7.4 Open Source Development</a></li>
        <li><a href="#Open Source Licensing" class="c7list">7.4.1 Open Source Licensing </a></li>
       
      </ul>
    </details>
  </nav>
</header>



    <main class="mt-20">
      
  <section>
    <div class="space-y-8">
        <article id="design" class="bg-amber-900 text-white border rounded-lg p-10 m-5 text-base leading-7 mt-30 scroll-mt-80">
            <section >
                <h1  class=" text-center mb-4 border-b-2 pb-2 font-bold text-2xl">DESIGN IMPLEMENTATION</h1>
            </section>
            <p >
                Software design and implementation is the stage in the software
                engineering process at which an executable software system is
                developed. For some simple systems, software design and
                implementation is software engineering, and all other activities are
                merged with this process. However, for large systems, software
                design and implementation is only one of a set of processes
                (requirements engineering, verification and validation, etc.)
                involved in software engineering.<br/>
            </p>
            <p>
                Software design and implementation activities are invariably
                interleaved. Software design is a creative activity in which you
                identify software components and their relationships, based on a
                customer’s requirements. Implementation is the process of realizing
                the design as a program. Sometimes, there is a separate design stage
                and this design is modeled and documented. At other times, a design
                is in the programmer’s head or roughly sketched on a whiteboard or
                sheets of paper. Design is about how to solve a problem, so there is
                always a design process. However, it isn’t always necessary or
                appropriate to describe the design in detail using the UML or other
                design description language.
            </p>
            <p>
                Design and implementation are closely linked and you should normally
                take implementation issues into account when developing a design.
                For example, using the UML to document a design may be the right
                thing to do if you are programming in an object-oriented language
                such as Java or C#. It is less useful, I think, if you are
                developing in a dynamically typed language like Python and makes no
                sense at all if you are implementing your system by configuring an
                off-the-shelf package. As I discussed in Chapter 3, agile methods
                usually work from informal sketches of the design and leave many
                design decisions to programmers.
            </p>
            <p class="mt-2">
                One of the most important implementation decisions that has to be
                made at an early stage of a software project is whether or not you
                should buy or build the application software. In a wide range of
                domains, it is now possible to buy off-the-shelf systems (COTS) that
                can be adapted and tailored to the users’ requirements. For example,
                if you want to implement a medical records system, you can buy a
                package that is already used in hospitals. It can be cheaper and
                faster to use this approach rather than developing a system in a
                conventional programming language.
            </p>
            <p>
                When you develop an application in this way, the design process
                becomes concerned with how to use the configuration features of that
                system to deliver the system requirements. You don’t usually develop
                design models of the system, such as models of the system objects
                and their interactions. I discuss this COTS-based approach to
                development in Chapter 16.
            </p>
            <p>
                I assume that most readers of this book will have had experience of
                program design and implementation. This is something that you
                acquire as you learn to program and master the elements of a
                programming language like Java or Python. You will have probably
                learned about good programming practice in the programming languages
                that you have studied, as well as how to debug programs that you
                have developed. Therefore, I don’t cover programming topics here.
                Instead, this chapter has two aims:
            </p>
            <ol>
                <li>
                    To show how system modeling and architectural design (covered in
                    Chapters 5 and 6) are put into practice in developing an
                    object-oriented software design.
                </li>
                <li>
                    To introduce important implementation issues that are not usually
                    covered in programming books. These include software reuse,
                    configuration management, and open source development.
                </li>
            </ol class="list-decimal">
            <p>
                As there are a vast number of different development platforms, the
                chapter is not biased towards any particular programming language or
                implementation technology. Therefore, I have presented all examples
                using the UML rather than in a programming language such as Java or
                Python.
            </p>
        </article>
    </div>
</section>

      

        <section class="scroll-mt-100">
    <div class="space-y-8">
        <article id="object" class=" bg-[#634832] text-white border rounded-lg p-10 m-5 text-base leading-7 scroll-mt-30">
            <section>
                <h1   class=" mb-4 border-b-2 pb-2 font-bold text-xl">7.1 Object-oriented design using the UML</h1>
            </section>
            <p>
                An object-oriented system is made up of interacting objects that
                maintain their own local state and provide operations on that state.
                The representation of the state is private and cannot be accessed
                directly from outside the object. Object-oriented design processes
                involve designing object classes and the relationships between these
                classes. These classes define the objects in the system and their
                interactions. When the design is realized as an executing program,
                the objects are created dynamically from these class definitions.
                Object-oriented systems are easier to change than systems developed
                using functional approaches. Objects include both data and
                operations to manipulate that data. They may therefore be understood
                and modified as stand-alone entities. Changing the implementation of
                an object or adding services should not affect other system objects.
                Because objects are associated with things, there is often a clear
                mapping between real-world entities (such as hardware components) and
                their controlling objects in the system. This improves the
                understandability, and hence the maintainability, of the design. To
                develop a system design from concept to detailed, object-oriented
                design, there are several things that you need to do:
            </p>
            <ol class="list-decimal pl-5 space-y-2">
                <li>Understand and define the context and the external interactions with the system.</li>
                <li>Design the system architecture.</li>
                <li>Identify the principal objects in the system.</li>
                <li>Develop design models</li>
                <li>Specify interfaces</li>
            </ol>
            <p>
                Like all creative activities, design is not a clear-cut, sequential
                process. You develop a design by getting ideas, proposing solutions,
                and refining these solutions as information becomes available. You
                inevitably have to backtrack and retry when problems arise.
                Sometimes you explore options in detail to see if they work; at
                other times you ignore details until late in the process.
                Consequently, I have deliberately not illustrated this process as a
                simple diagram because that would imply design can be thought of as
                a neat sequence of activities. In fact, all of the above activities
                are interleaved and so influence each other. I illustrate these
                process activities by designing part of the software for the
                wilderness weather station that I introduced in Chapter 1.
                Wilderness weather stations are deployed in remote areas. Each
                weather station records local weather information and periodically
                transfers this to a weather information system, using a satellite
                link.
            </p>
        </article>
    </div>
</section>



<section>
    <div class="space-y-8">
        <article id="system" class="border rounded-lg p-10 m-5 text-base leading-7 scroll-mt-30">
            <section>
                <h1  class=" mb-4 border-b-2 pb-2 font-bold text-xl">7.1.1 System context and interactions</h1>
            </section>
            <p>
                The first stage in any software design process is to develop an
                understanding of the relationships between the software that is
                being designed and its external environment. This is essential for
                deciding how to provide the required system functionality and how to
                structure the system to communicate with its environment.
                Understanding of the context also lets you establish the boundaries
                of the system. Setting the system boundaries helps you decide what
                features are implemented in the system being designed and what
                features are in other associated systems. In this case, you need to
                decide how functionality is distributed between the control system
                for all of the weather stations, and the embedded software in the
                weather station itself.
            </p>
            <p class="mb-2">
                System context models and interaction models present complementary
                views of the relationships between a system and its environment:
            </p>
            <ol class="list-decimal pl-5 space-y-2">
                <li>
                    A system context model is a structural model that demonstrates the
                    other systems in the environment of the system being developed.
                </li>
                <li>
                    An interaction model is a dynamic model that shows how the system
                    interacts with its environment as it is used.
                </li>
                <li>
                    An interaction model is a dynamic model that shows how the system
                    interacts with its environment as it is used.
                </li>
            </ol>
            <p>
                The context model of a system may be represented using associations.
                Associations simply show that there are some relationships between
                the entities involved in the association. The nature of the
                relationships is now specified. You may therefore document the
                environment of the system using a simple block diagram, showing the
                entities in the system and their associations. This is illustrated
                in Figure 7.1, which shows that
            </p>
            <p>
                the systems in the environment of each weather station are a weather
                information system, an onboard satellite system, and a control
                system. The cardinality information on the link shows that there is
                one control system but several weather stations, one satellite, and
                one general weather information system.
            </p>
            <p>
                When you model the interactions of a system with its environment you
                should use an abstract approach that does not include too much
                detail. One way to do this is to use a use case model. As I
                discussed in Chapters 4 and 5, each use case represents an
                interaction with the system. Each possible interaction is named in
                an ellipse and the external entity involved in the interaction is
                represented by a stick figure
            </p>
            <p>
                The use case model for the weather station is shown in Figure 7.2.
                This shows that the weather station interacts with the weather
                information system to report weather data and the status of the
                weather station hardware. Other interactions are with a control
                system that can issue specific weather station control commands. As
                I explained in Chapter 5, a stick figure is used in the UML to
                represent other systems as well as human users.
            </p>
            <p>
                Each of these use cases should be described in structured natural
                language. This helps designers identify objects in the system and
                gives them an understanding of what the system is intended to do. I
                use a standard format for this description that clearly identifies
                what information is exchanged, how the interaction is initiated, and
            </p>
            <figure class="text-center">
                <img
                    src="https://cs.ccsu.edu/~stan/classes/CS410/Notes16/images/07-context_model.png"
                    alt="Context Model"
                    class="mx-auto my-4 transition-transform duration-300 ease-in-out hover:scale-110 "
                    style="max-width: 50%; height: auto;"
                />
                <article>
                    <img
                        src="https://image1.slideserve.com/2401032/figure-7-2-weather-station-use-cases-l.jpg"
                        alt="Weather Station Use Cases"
                        class="mx-auto my-4 transition-transform duration-300 ease-in-out hover:scale-110"
                        style="max-width: 50%; height: auto;"
                    />
                </article>
            </figure>
            <p>
                so on. This is shown in Figure 7.3, which describes the Report
                weather use case from Figure 7.2. Examples of some other use cases
                are on the Web.
            </p>
        </article>
    </div>
</section>






          <section>
    <div class="space-y-8">
        <article id="Architectural" class="border rounded-lg p-10 m-5 text-base leading-7 scroll-mt-30">
            <section>
                <h1  class=" mb-4 border-b-2 pb-2 font-bold text-xl">7.1.2 Architectural design</h1>
            </section>
            <p>
                Once the interactions between the software system and the system’s
                environment have been defined, you use this information as a basis
                for designing the system architecture. Of course, you need to
                combine this with your general knowledge of the principles of
                architectural design and with more detailed domain knowledge.
            </p>

            <figure class="text-center">
                <img
                    src="Pictures/pic.png.png"
                    alt="Architectural Diagram 1"
                    class="mx-auto my-4"
                    style="max-width: 90%; height: auto;"
                />
            </figure>

            <figure class="text-center">
                <img
                    src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSi7a_T1yaeFl9UZf2mU5Kshq4PLM9m8MJBIw&ss"
                    alt="Architectural Diagram 2"
                    class="mx-auto my-4"
                    style="max-width: 90%; height: auto;"
                />
            </figure>

            <p>
                You identify the major components that make up the system and their
                interactions, and then may organize the components using an
                architectural pattern such as a layered or client–server model.
                However, this is not essential at this stage.
            </p>

            <p>
                The high-level architectural design for the weather station software
                is shown in Figure 7.4. The weather station is composed of
                independent subsystems that communicate by broadcasting messages on
                a common infrastructure, shown as the Communication link in Figure
                7.4. Each subsystem listens for messages on that infrastructure and
                picks up the messages that are intended for them. This is another
                commonly used architectural style in addition to those described in
                Chapter 6.
            </p>

            <p>
                For example, when the communications subsystem receives a control
                command, such as shutdown, the command is picked up by each of the
                other subsystems, which then shut themselves down in the correct
                way. The key benefit of this architecture is that it is easy to
                support different configurations of subsystems because the sender of
                a message does not need to address the message to a particular
                subsystem.
            </p>

            <p>
                Figure 7.5 shows the architecture of the data collection subsystem,
                which is included in Figure 7.4. The Transmitter and Receiver
                objects are concerned with managing communications and the
                WeatherData object encapsulates the information that is collected
                from the instruments and transmitted to the weather information
                system. This arrangement follows the producer-consumer pattern,
                discussed in Chapter 20.
            </p>
        </article>
    </div>
</section>



         <section>
    <div class="space-y-8">
        <article class="border rounded-lg p-10 m-5 text-base leading-7">
            <h1 id="OBJECT CLASS" class="mb-4 border-b-2 pb-2 font-bold text-xl">7.1.3 Object Class Identification</h1>

            <p>
                By this stage in the design process, you should have some ideas
                about the essential objects in the system that you are designing. As
                your understanding of the design develops, you refine these ideas
                about the system objects. The use case description helps to identify
                objects and operations in the system. From the description of the
                Report weather use case, it is obvious that objects representing the
                instruments that collect weather data will be required, as will an
                object representing the summary of the weather data. You also
                usually need a high-level system object or objects that encapsulate
                the system interactions defined in the use cases. With these objects
                in mind, you can start to identify the object classes in the system.
            </p>

            <figure class="text-center">
                <img
                    src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTUDer3GU5vZlNTa9XYlLco3cBEUkQf8fBVHQ&s"
                    alt="Weather Instruments"
                    class="max-w-full h-auto max-h-96 mx-auto" />
            </figure>

            <p>
                There have been various proposals made about how to identify object
                classes in object-oriented systems:
            </p>

            <ol class="list-decimal pl-5">
                <li>
                    Use a grammatical analysis of a natural language description of
                    the system to be constructed. Objects and attributes are nouns;
                    operations or services are verbs (Abbott, 1983).
                </li>
                <li>
                    Use tangible entities (things) in the application domain such as
                    aircraft, roles such as manager or doctor, events such as
                    requests, interactions such as meetings, locations such as
                    offices, organizational units such as companies, and so on (Coad
                    and Yourdon, 1990; Shlaer and Mellor, 1988; Wirfs-Brock et al.,
                    1990).
                </li>
                <li>
                    Use a scenario-based analysis where various scenarios of system
                    use are identified and analyzed in turn. As each scenario is
                    analyzed, the team responsible for the analysis must identify the
                    required objects, attributes, and operations (Beck and Cunningham,
                    1989).
                </li>
            </ol>

            <p>
                In practice, you have to use several knowledge sources to discover
                object classes. Object classes, attributes, and operations that are
                initially identified from the informal system description can be a
                starting point for the design. Further information from application
                domain knowledge or scenario analysis may then be used to refine and
                extend the initial objects. This information can be collected from
                requirements documents, discussions with users, or from analyses of
                existing systems.
            </p>

            <p>
                In the wilderness weather station, object identification is based on
                the tangible hardware in the system. I don’t have space to include
                all the system objects here, but I have shown five object classes in
                Figure 7.6. The Ground thermometer, Anemometer, and Barometer objects
                are application domain objects, and the WeatherStation and WeatherData
                objects have been identified from the system description and the scenario
                (use case) description:
            </p>

            <ol class="list-decimal pl-5">
                <li>
                    The WeatherStation object class provides the basic interface of
                    the weather station with its environment. Its operations reflect
                    the interactions shown in
                </li>
                <figure class="text-center">
                    <img
                        src="https://d2vlcm61l7u1fs.cloudfront.net/media%2F771%2F77158d1e-f968-4378-b5b2-d9c3e0bdaff5%2FphpVV9v4I.png"
                        class="max-w-full h-auto max-h-96 mx-auto" alt="Weather Station Diagram" />
                </figure>

                <li>
                    The WeatherData object class is responsible for processing the
                    report weather command. It sends the summarized data from the
                    weather station instruments to the weather information system.
                </li>

                <li>
                    The Ground thermometer, Anemometer, and Barometer object classes
                    are directly related to instruments in the system. They reflect
                    tangible hardware entities in the system, and the operations are
                    concerned with controlling that hardware. These objects operate
                    autonomously to collect data at the specified frequency and store
                    the collected data locally. This data is delivered to the WeatherData
                    object on request.
                </li>
            </ol>

            <p>
                You use knowledge of the application domain to identify other objects,
                attributes, and services. We know that weather stations are often located
                in remote places and include various instruments that sometimes go wrong.
                Instrument failures should be reported automatically. This implies that
                you need attributes and operations to check the correct functioning of the
                instruments. There are many remote weather stations, so each weather
                station should have its own identifier.
            </p>

            <p>
                At this stage in the design process, you should focus on the objects
                themselves, without thinking about how these might be implemented. Once
                you have identified the objects, you then refine the object design. You
                look for common features and then design the inheritance hierarchy for
                the system. For example, you may identify an Instrument superclass,
                which defines the common features of all instruments, such as an identifier,
                and get and test operations. You may also add new attributes and operations
                to the superclass, such as an attribute that maintains the frequency of data
                collection.
            </p>
        </article>
    </div>
</section>






  <section>
  <div class="space-y-8">
    <article class="border rounded-lg p-8 m-5 text-base leading-7">
      <h3 id="design models" class=" mb-4 border-b-2 pb-2 font-bold text-xl">7.1.4 Design Models</h3>
      <p>
        Design or system models, as I discussed in Chapter 5, show the
        objects or object classes in a system. They also show the
        associations and relationships between these entities. These models
        are the bridge between the system requirements and the
        implementation of a system. They have to be abstract so that
        unnecessary detail doesn’t hide the relationships between them and
        the system requirements.
      </p>
      <p>
        However, they also have to include enough detail for programmers to
        make implementation decisions.
      </p>
      <p>
        Generally, you get around this type of conflict by developing models
        at different levels of detail. Where there are close links between
        requirements engineers, designers, and programmers, then abstract
        models may be all that are required. Specific design decisions may
        be made as the system is implemented, with problems resolved through
        informal discussions. When the links between system specifiers,
        designers, and programmers are indirect (e.g., where a system is
        being designed in one part of an organization but implemented
        elsewhere), then more detailed models are likely to be needed.
      </p>
      <p>
        An important step in the design process, therefore, is to decide on
        the design models that you need and the level of detail required in
        these models. This depends on the type of system that is being
        developed. You design a sequential data-processing system in a
        different way from an embedded real-time system, so you will need
        different design models. The UML supports 13 different types of
        models but, as I discussed in Chapter 5, you rarely use all of
        these. Minimizing the number of models that are produced reduces the
        costs of the design and the time required to complete the design
        process.
      </p>
      <p>
        When you use the UML to develop a design, you will normally develop
        two kinds of design model:
      </p>

      <ol class="list-decimal pl-5">
        <li>
          Structural models, which describe the static structure of the
          system using object classes and their relationships. Important
          relationships that may be documented at this stage are
          generalization (inheritance) relationships, uses/used-by
          relationships, and composition relationships.
        </li>
        <li>
          Dynamic models, which describe the dynamic structure of the system
          and show the interactions between the system objects. Interactions
          that may be documented include the sequence of service requests
          made by objects and the state changes that are triggered by these
          object interactions.
        </li>
      </ol>

      <p>
        In the early stages of the design process, I think there are three
        models that are particularly useful for adding detail to use case
        and architectural models:
      </p>

      <ol class="list-decimal pl-5">
        <li>
          Subsystem models, which show logical groupings of objects into
          coherent subsystems. These are represented using a form of class
          diagram with each subsystem shown as a package with enclosed
          objects. Subsystem models are static (structural) models.
        </li>
        <figure class="text-center my-6">
          <img
            src="https://image1.slideserve.com/2401032/figure-7-7-sequence-diagram-describing-data-collection-l.jpg"
            alt="Sequence Diagram"
            class="max-w-full h-auto max-h-96 mx-auto"
          />
        </figure>

        <li>
          Sequence models, which show the sequence of object interactions.
          These are represented using a UML sequence or a collaboration
          diagram. Sequence models are dynamic models.
        </li>
        <li>
          State machine models, which show how individual objects change
          their state in response to events. These are represented in the
          UML using state diagrams. State machine models are dynamic models.
        </li>
      </ol>

      <p>
        A subsystem model is a useful static model as it shows how a design
        is organized into logically related groups of objects. I have
        already shown this type of model in Figure 7.4 to show the
        subsystems in the weather mapping system. As well as subsystem
        models, you may also design detailed object models, showing all of
        the objects in the systems and their associations (inheritance,
        generalization, aggregation, etc.). However, there is a danger in
        doing too much modeling. You should not make detailed decisions
        about the implementation that really should be left to the system
        programmers.
      </p>

      <p>
        Sequence models are dynamic models that describe, for each mode of
        interaction, the sequence of object interactions that take place.
        When documenting a design, you should produce a sequence model for
        each significant interaction. If you have developed a use case model
        then there should be a sequence model for each use case that you
        have identified.
      </p>

      <p>
        Figure 7.7 is an example of a sequence model, shown as a UML
        sequence diagram. This diagram shows the sequence of interactions
        that take place when an external system requests the summarized data
        from the weather station. You read sequence diagrams from top to
        bottom:
      </p>

      <ol class="list-decimal pl-5">
        <li>
          The SatComms object receives a request from the weather
          information system to collect a weather report from a weather
          station. It acknowledges receipt of this request. The stick
          arrowhead on the sent message indicates that the external system
          does not wait for a reply but can carry on with other processing.
        </li>
        <li>
          SatComms sends a message to WeatherStation, via a satellite link,
          to create a summary of the collected weather data. Again, the
          stick arrowhead indicates that SatComms does not suspend itself
          waiting for a reply.
        </li>
        <li>
          WeatherStation sends a message to a Commslink object to summarize
          the weather data. In this case, the squared-off style of arrowhead
          indicates that the instance of the WeatherStation object class
          waits for a reply.
        </li>
        <li>
          Commslink calls the summarize method in the object WeatherData and
          waits for a reply.
        </li>
        <li>
          The weather data summary is computed and returned to
          WeatherStation via the Commslink object.
        </li>
        <li>
          WeatherStation then calls the SatComms object to transmit the
          summarized data to the weather information system, through the
          satellite communications system.
        </li>
      </ol>
    </article>
  </div>
</section>


        





   <section>
  <div class="space-y-8">
    <article class="border rounded-lg p-8 m-5 text-base leading-7">
      <h3 id="interface" class=" mb-4 border-b-2 pb-2 font-bold text-xl">7.1.5 Interface Specification</h3>

      <p>
        An important part of any design process is the specification of the
        interfaces between the components in the design. You need to specify
        interfaces so that objects and subsystems can be designed in
        parallel. Once an interface has been specified, the developers of
        other objects may assume that interface will be implemented.
      </p>

      <p>
        Interface design is concerned with specifying the detail of the
        interface to an object or to a group of objects. This means defining
        the signatures and semantics of
      </p>

      <figure class="my-6 text-center">
        <img
          src="https://image1.slideserve.com/2401032/figure-7-9-weather-station-interfaces-l.jpg"
          alt="Weather Station Interfaces"
          class="max-w-full h-auto max-h-96 mx-auto"
        />
      </figure>

      <p>
        the services that are provided by the object or by a group of
        objects. Interfaces can be specified in the UML using the same
        notation as a class diagram. However, there is no attribute section
        and the UML stereotype ‹‹interface›› should be included in the name
        part. The semantics of the interface may be defined using the object
        constraint language (OCL). I explain this in Chapter 17, where I
        cover component-based software engineering. I also show an
        alternative way to represent interfaces in the UML. You should not
        include details of the data representation in an interface design,
        as attributes are not defined in an interface specification.
        However, you should include operations to access and update data. As
        the data representation is hidden, it can be easily changed without
        affecting the objects that use that data. This leads to a design
        that is inherently more maintainable. For example, an array
        representation of a stack may be changed to a list representation
        without affecting other objects that use the stack. By contrast, it
        often makes sense to expose the attributes in a static design model,
        as this is the most compact way of illustrating essential
        characteristics of the objects.
      </p>

      <p>
        There is not a simple 1:1 relationship between objects and
        interfaces. The same object may have several interfaces, each of
        which is a viewpoint on the methods that it provides. This is
        supported directly in Java, where interfaces are declared separately
        from objects and objects ‘implement’ interfaces. Equally, a group of
        objects may all be accessed through a single interface.
      </p>

      <p>
        Figure 7.9 shows two interfaces that may be defined for the weather
        station. The left-hand interface is a reporting interface that
        defines the operation names that are used to generate weather and
        status reports. These map directly to operations in the
        WeatherStation object. The remote control interface provides four
        operations, which map onto a single method in the WeatherStation
        object. In this case, the individual operations are encoded in the
        command string associated with the remoteControl method, shown in
        Figure 7.6.
      </p>
    </article>
  </div>
</section>







 <section>
  <div class="space-y-8">
    <article class="border rounded-lg p-10 m-5 text-base leading-7">
      <h3 id="design patterns" class=" mb-4 border-b-2 pb-2 text-2xl font-semibold">7.2 Design patterns</h3>
      <p>
        Design patterns were derived from ideas put forward by Christopher
        Alexander (Alexander et al., 1977), who suggested that there were
        certain common patterns of building design that were inherently
        pleasing and effective. The pattern is a description of the problem
        and the essence of its solution, so that the solution may be reused
        in different settings.
      </p>

      
      <figure class="text-center my-4">
        <img src="Pictures/comment.png" alt="" class="max-w-[80%] mx-auto" />
      </figure>

      <p>
        The pattern is not a detailed specification. Rather, you can think of it as a description of accumulated wisdom
        and experience, a well-tried solution to a common problem.
      </p>

      <p>
        A quote from the Hillside Group web site (http://hillside.net), which is dedicated to maintaining information about patterns, encapsulates their role in reuse:
      </p>

      <p>
        Patterns and Pattern Languages are ways to describe best practices, good designs, and capture experience in a way that it is possible for others to reuse this experience.
      </p>

      <p>
        Patterns have made a huge impact on object-oriented software design. As well as being tested solutions to common problems, they have become a vocabulary for talking about a design. You can therefore explain your design by describing the patterns that you have used.
        This is particularly true for the best-known design patterns that were originally described by the ‘Gang of Four’ in their patterns book, (Gamma et al., 1995).
        Other particularly important pattern descriptions are those published in a series of books by authors from Siemens, a large European technology company (Buschmann et al., 1996; Buschmann et al., 2007a; Buschmann et al., 2007b; Kircher and Jain, 2004; Schmidt et al., 2000).
      </p>

      <p>
        Design patterns are usually associated with object-oriented design. Published patterns often rely on object characteristics such as inheritance and polymorphism to provide generality. However, the general principle of encapsulating experience in a pattern is one that is equally applicable to any kind of software design. 
        So, you could have configuration patterns for COTS systems. Patterns are a way of reusing the knowledge and experience of other designers.
      </p>

      <p>
        The four essential elements of design patterns were defined by the ‘Gang of Four’ in their patterns book:
      </p>

      <ol class="list-decimal ml-5 space-y-2">
        <li>A name that is a meaningful reference to the pattern.</li>
        <li>
          A description of the problem area that explains when the pattern
          may be applied.
        </li>
        <li>
          A solution description of the parts of the design solution, their
          relationships, and their responsibilities. This is not a concrete
          design description. It is a template for a design solution that
          can be instantiated in different ways. This is often expressed
          graphically and shows the relationships between the objects and
          object classes in the solution.
        </li>
        <li>
          A statement of the consequences—the results and trade-offs—of
          applying the pattern. This can help designers understand whether
          or not a pattern can be used in a particular situation.
        </li>
      </ol>

      <p>
        Gamma and his co-authors break down the problem description into motivation (a description of why the pattern is useful) and applicability (a description of situations in which the pattern may be used). Under the description of the solution, they describe the pattern structure, participants, collaborations, and implementation.
      </p>

      <p>
        To illustrate pattern description, I use the Observer pattern, taken from the book by Gamma et al. (Gamma et al., 1995). This is shown in Figure 7.10. In my description, I use the four essential description elements and also include a brief statement of what the pattern can do. This pattern can be used in situations where different presentations of an object’s state are required. It separates the object that must be displayed from the different forms of presentation. This is illustrated in Figure 7.11, which shows two graphical presentations of the same data set.
      </p>

      <p>
        Graphical representations are normally used to illustrate the object classes in patterns and their relationships. These supplement the pattern description and add detail to the solution description. Figure 7.12 is the representation in UML of the Observer pattern.
      </p>

     
      <figure class="text-center my-4">
        <img src="Pictures/piktur.png" alt="" class="max-w-[80%] mx-auto" />
      </figure>

      <p>
        To use patterns in your design, you need to recognize that any design problem you are facing may have an associated pattern that can be applied. Examples of such problems, documented in the ‘Gang of Four’s original patterns book, include:
      </p>

      <ol class="list-decimal ml-5 space-y-2">
        <li>
          Tell several objects that the state of some other object has
          changed (Observer pattern).
        </li>
        <li>
          Tidy up the interfaces to a number of related objects that have
          often been developed incrementally (Façade pattern).
        </li>
        <li>
          Provide a standard way of accessing the elements in a collection,
          irrespective of how that collection is implemented (Iterator
          pattern).
        </li>
        <li>
          Allow for the possibility of extending the functionality of an
          existing class at run-time (Decorator pattern).
        </li>
      </ol>

      <p>
        Patterns support high-level, concept reuse. When you try to reuse
        executable components you are inevitably constrained by detailed
        design decisions that have been made by the implementers of these
        components. These range from the particular algorithms that have
        been used to implement the components to the objects and types in
        the component interfaces. When these design decisions conflict with
        your particular requirements, reusing the component is either
        impossible or introduces inefficiencies into your system. Using
        patterns means that you reuse the ideas but can adapt the
        implementation to suit the system that you are developing.
      </p>

      <p>
        When you start designing a system, it can be difficult to know, in
        advance, if you will need a particular pattern. Therefore, using
        patterns in a design process often involves developing a design,
        experiencing a problem, and then recognizing that a pattern can be
        used. This is certainly possible if you focus on the 23
        general-purpose patterns documented in the original patterns book.
        However, if your problem is a different one, you may find it
        difficult to find an appropriate pattern amongst the hundreds of
        different patterns that have been proposed. Patterns are a great
        idea but you need experience effectively. You have to recognize situations where a pattern can be
        applied. Inexperienced programmers, even if they have read the
        pattern books, will always find it hard to decide whether they can
        reuse a pattern or need to develop a special-purpose solution.
      </p>
    </article>
  </div>
</section>





  <section>
  <div class="space-y-8">
    <article class="border rounded-lg p-10 m-5 text-base leading-7">
      <h3 id="implementation" class="mb-4 border-b-2 pb-2 text-2xl font-semibold">7.3 Implementation Issues</h3>

      <p>
        Software engineering includes all of the activities involved in
        software development from the initial requirements of the system
        through to maintenance and management of the deployed system. A
        critical stage of this process is, of course, system implementation,
        where you create an executable version of the software.
        Implementation may involve developing programs in high- or low-level
        programming languages or tailoring and adapting generic,
        off-the-shelf systems to meet the specific requirements of an
        organization.
      </p>

      <p>
        I assume that most readers of this book will understand programming
        principles and will have some programming experience. As this
        chapter is intended to offer a language-independent approach, I
        haven’t focused on issues of good programming practice as this has
        to use language-specific examples. Instead, I introduce some aspects
        of implementation that are particularly important to software
        engineering that are often not covered in programming texts. These
        are:
      </p>

      <ol class="list-decimal ml-5 space-y-2">
        <li>
          <strong>Reuse:</strong> Most modern software is constructed by reusing existing
          components or systems. When you are developing software, you
          should make as much use as possible of existing code.
        </li>
        <li>
          <strong>Configuration management:</strong> During the development process, many
          different versions of each software component are created. If you
          don’t keep track of these versions in a configuration management
          system, you are liable to include the wrong versions of these
          components in your system.
        </li>
        <li>
          <strong>Host-target development:</strong> Production software does not usually
          execute on the same computer as the software development
          environment. Rather, you develop it on one computer (the host
          system) and execute it on a separate computer (the target system).
          The host and target systems are sometimes of the same type but,
          often they are completely different.
        </li>
      </ol>
    </article>
  </div>
</section>



          




         <section>
  <div class="space-y-8">
    <article class="border rounded-lg p-10 m-5 text-base leading-7">
      <h3 id="configuration" class=" mb-4 border-b-2 pb-2 text-2xl font-semibold">7.3.2 Configuration Management</h3>

      <p>
        In software development, change happens all the time, so change
        management is absolutely essential. When a team of people are
        developing software, you have to make sure that team members don’t
        interfere with each others’ work. That is, if two people are working
        on a component, their changes have to be coordinated. Otherwise, one
        programmer may make changes and overwrite the other’s work. You also
        have to ensure that everyone can access the most up-to-date versions
        of software components, otherwise developers may redo work that has
        already been done. When something goes wrong with a new version of a
        system, you have to be able to go back to a working version of the
        system or component.
      </p>

      <p>
        Configuration management is the name given to the general process of
        managing a changing software system. The aim of configuration
        management is to support the system integration process so that all
        developers can access the project code and documents in a controlled
        way, find out what changes have been made, and compile and link
        components to create a system. There are, therefore, three
        fundamental configuration management activities:
      </p>

      <ol class="list-decimal ml-5 space-y-2">
        <li>
          <strong>Version management:</strong> Support is provided to keep track of the
          different versions of software components. Version management
          systems include facilities to coordinate development by several
          programmers. They stop one developer from overwriting code that has
          been submitted to the system by someone else.
        </li>
        <li>
          <strong>System integration:</strong> Support is provided to help developers
          define what versions of components are used to create each version
          of a system. This description is then used to build a system
          automatically by compiling and linking the required components.
        </li>
        <li>
          <strong>Problem tracking:</strong> Support is provided to allow users to
          report bugs and other problems, and to allow all developers to see
          who is working on these problems and when they are fixed.
        </li>
      </ol>

      <p>
        Software configuration management tools support each of the above
        activities. These tools may be designed to work together in a
        comprehensive change management system, such as ClearCase (Bellagio
        and Milligan, 2005). In integrated configuration management systems,
        version management, system integration, and problem-tracking tools
        are designed together. They share a user interface style and are
        integrated through a common code repository.
      </p>

      <p>
        Alternatively, separate tools, installed in an integrated
        development environment, may be used. Version management may be
        supported using a version management system such as Subversion
        (Pilato et al., 2008), which can support multi-site, multiteam
        development. System integration support may be built into the
        language or rely on a separate toolset such as the GNU build system.
        This includes what is perhaps the best-known integration tool, Unix
        make. Bug tracking or issue tracking systems, such as Bugzilla, are
        used to report bugs and other issues and to keep track of whether or
        not these have been fixed.
      </p>

      <p>
        Because of its importance in professional software engineering, I
        discuss change and configuration management in more detail in
        Chapter 25.
      </p>
    </article>
  </div>
</section>


          <section>
  <div class="space-y-8">
    <article class="border rounded-lg p-10 m-5 text-base leading-7">
      <h3 id="host-target" class=" mb-4 border-b-2 pb-2 text-2xl font-semibold">7.3.3 Host-target Development</h3>

      <p>
        Most software development is based on a host-target model. Software
        is developed on one computer (the host), but runs on a separate
        machine (the target). More generally, we can talk about a
        development platform and an execution platform. A platform is more
        than just hardware. It includes the installed operating system plus
        other supporting software such as a database management system or,
        for development platforms, an interactive development environment.
      </p>

      <p>
        Sometimes, the development and execution platforms are the same,
        making it possible to develop the software and test it on the same
        machine. More commonly, however, they are different so that you need
        to either move your developed software to the execution platform for
        testing or run a simulator on your development machine.
      </p>

      <p>
        Simulators are often used when developing embedded systems. You
        simulate hardware devices, such as sensors, and the events in the
        environment in which the system will be deployed. Simulators speed
        up the development process for embedded systems as each developer
        can have their own execution platform with no need to download the
        software to the target hardware. However, simulators are expensive
        to develop and so are only usually available for the most popular
        hardware architectures.
      </p>

      <p>
        If the target system has installed middleware or other software that
        you need to use, then you need to be able to test the system using
        that software. It may be impractical to install that software on
        your development machine, even if it is the same as the target
        platform, because of license restrictions. In those circumstances,
        you need to transfer your developed code to the execution platform
        to test the system.
      </p>

      <p>
        A software development platform should provide a range of tools to
        support software engineering processes. These may include:
      </p>

      <ol class="list-decimal ml-5 space-y-2">
        <li>
          <strong>An integrated compiler and syntax-directed editing system:</strong> Allows you to create, edit, and compile code.
        </li>
        <li><strong>A language debugging system:</strong> For error detection and resolution during development.</li>
        <li><strong>Graphical editing tools:</strong> Such as tools to edit UML models.</li>
        <li>
          <strong>Testing tools:</strong> Such as JUnit (Massol, 2003), which can automatically run a set of tests on a new version of a program.
        </li>
        <li>
          <strong>Project support tools:</strong> That help you organize the code for different development projects.
        </li>
      </ol>

      <p>
        As well as these standard tools, your development system may include
        more specialized tools such as static analyzers (discussed in
        Chapter 15). Normally, development environments for teams also
        include a shared server that runs a change and configuration
        management system and, perhaps, a system to support requirements
        management.
      </p>

      <p>
        Software development tools are often grouped to create an integrated
        development environment (IDE). An IDE is a set of software tools
        that supports different aspects of software development, within some
        common framework and user interface. Generally, IDEs are created to
        support development in a specific programming language such as Java.
        The language IDE may be developed specially, or may be an
        instantiation of a general-purpose IDE, with specific
        language-support tools.
      </p>

      <p>
        A general-purpose IDE is a framework for hosting software tools that
        provides data management facilities for the software being
        developed, and integration mechanisms, that allow tools to work
        together. The best-known general-purpose IDE is the Eclipse
        environment (Carlson, 2005). This environment is based on a plug-in
        architecture so that it can be specialized for different languages
        and application domains (Clayberg and Rubel, 2006). Therefore, you
        can install Eclipse and tailor it for your specific needs by adding
        plug-ins. For example, you may add a set of plug-ins to support
        networked systems development in Java or embedded systems
        engineering using C.
      </p>

      <p>
        As part of the development process, you need to make decisions about
        how the developed software will be deployed on the target platform.
        This is straightforward for embedded systems, where the target is
        usually a single computer. However, for distributed systems, you
        need to decide on the specific platforms where the components will
        be deployed. Issues that you have to consider in making this
        decision are:
      </p>

      <ol class="list-decimal ml-5 space-y-2">
        <li>
          <strong>The hardware and software requirements of a component:</strong> If a component is designed for a specific hardware architecture, or
          relies on some other software system, it must obviously be
          deployed on a platform that provides the required hardware and
          software support.
        </li>
        <li>
          <strong>The availability requirements of the system:</strong> High-availability systems may require components to be deployed on more than one
          platform. This means that, in the event of platform failure, an
          alternative implementation of the component is available.
        </li>
        <li>
          <strong>Component communications:</strong> If there is a high level of
          communications traffic between components, it usually makes sense
          to deploy them on the same platform or on platforms that are
          physically close to one other. This reduces communications
          latency, the delay between the time a message is sent by one
          component and received by another.
        </li>
      </ol>

      <p>
        You can document your decisions on hardware and software deployment
        using UML deployment diagrams, which show how software components
        are distributed across hardware platforms.
      </p>

      <p>
        If you are developing an embedded system, you may have to take into
        account target characteristics, such as its physical size, power
        capabilities, the need for realtime responses to sensor events, the
        physical characteristics of actuators, and its realtime operating
        system. I discuss embedded systems engineering in Chapter 20.
      </p>
    </article>
  </div>
</section>


         <section>
    <div class="space-y-8">
        <article class="border rounded-lg p-10 m-5 text-base leading-7">
            <section>
                <h1 id="open source" class=" mb-4 border-b-2 pb-2 font-bold text-xl">7.4 Open Source Development</h1>
            </section>
            <p>
                Open source development is an approach to software development in
                which the source code of a software system is published and
                volunteers are invited to participate in the development process
                (Raymond, 2001). Its roots are in the Free Software Foundation
                (http://www.fsf.org), which advocates that source code should not be
                proprietary but rather should always be available for users to
                examine and modify as they wish. There was an assumption that the
                code would be controlled and developed by a small core group, rather
                than users of the code.
            </p>
            <p>
                Open source software extended this idea by using the Internet to
                recruit a much larger population of volunteer developers. Many of
                them are also users of the code. In principle at least, any
                contributor to an open source project may report and fix bugs and
                propose new features and functionality. However, in practice,
                successful open source systems still rely on a core group of
                developers who control changes to the software.
            </p>
            <p>
                The best-known open source product is, of course, the Linux
                operating system which is widely used as a server system and,
                increasingly, as a desktop environment. Other important open source
                products are Java, the Apache web server, and the mySQL database
                management system. Major players in the computer industry such as
                IBM and Sun support the open source movement and base their software
                on open source products. There are thousands of other, lesser known
                open source systems and components that may also be used.
            </p>
            <p>
                It is usually fairly cheap or free to acquire open source software.
                You can normally download open source software without charge.
                However, if you want documentation and support, then you may have to
                pay for this, but costs are usually fairly low. The other key
                benefit of using open source products is that mature open source
                systems are usually very reliable. The reason for this is that they
                have a large population of users who are willing to fix problems
                themselves rather than report these problems to the developer and
                wait for a new release of the system. Bugs are discovered and
                repaired more quickly than is usually possible with proprietary
                software.
            </p>
            <p>
                For a company involved in software development, there are two open
                source issues that have to be considered:
            </p>
            <ol class="list-decimal pl-6">
                <li>
                    Should the product that is being developed make use of open source
                    components?
                </li>
                <li>
                    Should an open source approach be used for the software’s
                    development?
                </li>
            </ol>
            <p>
                The answers to these questions depend on the type of software that
                is being developed and the background and experience of the
                development team.
            </p>
            <p>
                If you are developing a software product for sale, then time to
                market and reduced costs are critical. If you are developing in a
                domain in which there are high-quality open source systems
                available, you can save time and money by using these systems.
            </p>
            <p>
                However, if you are developing software to a specific set of
                organizational requirements, then using open source components may
                not be an option. You may have to integrate your software with
                existing systems that are incompatible with available open source
                systems. Even then, however, it could be quicker and cheaper to
                modify the open source system rather than redevelop the
                functionality that you need.
            </p>
            <p>
                More and more product companies are using an open source approach to
                development. Their business model is not reliant on selling a
                software product but rather on selling support for that product.
                They believe that involving the open source community will allow
                software to be developed more cheaply, more quickly, and will create
                a community of users for the software. Again, however, this is
                really only applicable for general software products rather than
                specific organizational applications.
            </p>
            <p>
                Many companies believe that adopting an open source approach will
                reveal confidential business knowledge to their competitors and so
                are reluctant to adopt this development model. However, if you are
                working in a small company and you open source your software, this
                may reassure customers that they will be able to support the
                software if your company goes out of business.
            </p>
            <p>
                Publishing the source code of a system does not mean that people
                from the wider community will necessarily help with its development.
                Most successful open source products have been platform products
                rather than application systems. There are a limited number of
                developers who might be interested in specialized application
                systems. As such, making a software system open source does not
                guarantee community involvement.
            </p>
        </article>
    </div>
</section>

<section>
    <div class="space-y-8">
        <article class="border rounded-lg p-10 m-5 text-base leading-7">
            <section>
                <h1 id="Open Source Licensing" class="mb-4 border-b-2 pb-2 font-bold text-xl">7.4.1 Open Source Licensing</h1>
            </section>
            <p>
                Although a fundamental principle of open-source development is that
                source code should be freely available, this does not mean that
                anyone can do as they wish with that code. Legally, the developer of
                the code (either a company or an individual) still owns the code.
                They can place restrictions on how it is used by including legally
                binding conditions in an open source software license (St. Laurent,
                2004). Some open source developers believe that if an open source
                component is used to develop a new system, then that system should
                also be open source. Others are willing to allow their code to be
                used without this restriction. The developed systems may be
                proprietary and sold as closed source systems.
            </p>
            <p>
                Most open source licenses are derived from one of three general
                models:
            </p>
            <ol class="list-decimal pl-6">
                <li>
                    The GNU General Public License (GPL). This is a so-called
                    ‘reciprocal’ license that, simplistically, means that if you use
                    open source software that is licensed under the GPL license, then
                    you must make that software open source.
                </li>
                <li>
                    The GNU Lesser General Public License (LGPL). This is a variant of
                    the GPL license where you can write components that link to open
                    source code without having to publish the source of these
                    components. However, if you change the licensed component, then
                    you must publish this as open source.
                </li>
                <li>
                    The Berkley Standard Distribution (BSD) License. This is a
                    non-reciprocal license, which means you are not obliged to
                    republish any changes or modifications made to open source code.
                    You can include the code in proprietary systems that are sold. If
                    you use open source components, you must acknowledge the original
                    creator of the code.
                </li>
            </ol>
            <p>
                Licensing issues are important because if you use open-source
                software as part of a software product, then you may be obliged by
                the terms of the license to make your own product open source. If
                you are trying to sell your software, you may wish to keep it
                secret. This means that you may wish to avoid using GPL-licensed
                open source software in its development.
            </p>
            <p>
                If you are building software that runs on an open source platform,
                such as Linux, then licenses are not a problem. However, as soon as
                you start including open source components in your software you need
                to set up processes and databases to keep track of what’s been used
                and their license conditions. Bayersdorfer (2007) suggests that
                companies managing projects that use open source should:
            </p>
            <ol class="list-decimal pl-6">
                <li>
                    Establish a system for maintaining information about open source
                    components that are downloaded and used. You have to keep a copy
                    of the license for each component that was valid at the time the
                    component was used. Licenses may change so you need to know the
                    conditions that you have agreed to.
                </li>
                <li>
                    Be aware of the different types of licenses and understand how a
                    component is licensed before it is used. You may decide to use a
                    component in one system but not in another because you plan to use
                    these systems in different ways.
                </li>
                <li>
                    Be aware of evolution pathways for components. You need to know a
                    bit about the open source project where components are developed
                    to understand how they might change in future.
                </li>
                <li>
                    Educate people about open source. It’s not enough to have
                    procedures in place to ensure compliance with license conditions.
                    You also need to educate developers about open source and open
                    source licensing.
                </li>
                <li>
                    Have auditing systems in place. Developers, under tight deadlines,
                    might be tempted to break the terms of a license. If possible, you
                    should have software in place to detect and stop this.
                </li>
                <li>
                    Participate in the open source community. If you rely on open
                    source products, you should participate in the community and help
                    support their development.
                </li>
            </ol>
            <p>
                The business model of software is changing. It is becoming
                increasingly difficult to build a business by selling specialized
                software systems. Many companies prefer to make their software open
                source and then sell support and consultancy to software users. This
                trend is likely to accelerate, with increasing use of open source
                software and with more and more software available in this form.
            </p>
        </article>
    </div>
</section>


        </article>
      </section>
    </main>
   <footer class="bg-opacity-80 c7footer">
  <div class="c7footer2">

    <a href="https://web.facebook.com/adziel.macalindong" target="_blank" aria-label="Facebook">
      <img src="/Pictures/facebook.png" alt="Facebook"
        class="c7icon">
    </a>

    <a href="" target="_blank" aria-label="Instagram">
      <img src="/Pictures/instagram.png" alt="Instagram"
        class="c7icon">
    </a>

    <a href="23-12778@g.batstate-u.edu.ph" aria-label="Email">
      <img src="/Pictures/mail.png" alt="Email"
        class="c7icon">
    </a>

    <a href="tel:+63XXXXXXXXXX" aria-label="Telephone">
      <img src="/Pictures/telephone.png" alt="Telephone"
        class="c7icon">
    </a>
  </div>

  <p class="text-xs sm:c2text sour-gummy-sm md:c2text sour-gummy-base lg:text-lg xl:text-xl text-gray-800 font-medium tracking-wide">
    © 2025 Software Engineering. All rights reserved.
  </p>
</footer>
  </body>
</html>
